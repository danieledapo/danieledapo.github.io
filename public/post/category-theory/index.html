<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>d&amp;#39;</title>
    <link rel='icon' href='/favicon.ico' type='image/x-icon' />
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/main.css">


    </head>

<body class="site">
    <main class="site-content">
 <nav class="container navbar" role="navigation">
    <div class="logo">
        <a href='/'>
            <img src="/logo.svg" alt="d&#39;">
        </a>
    </div>

    <ul class="nav-links">
        <a href='/'>
            <span>
                Blog
            </span>
        </a>
        <a href='/about/'>
            <span>
                About
            </span>
        </a>
        <a href='/library/'>
            <span>
                Library
            </span>
        </a>
    </ul>
</nav>


<section class="container">

  <span>
    
    Jan 10, 2019 - 19 Minute Read
    
  </span>
  <p class="post-title">
    <a href="https://danieledapo.github.io/post/category-theory/">
      Notes on Category Theory
    </a>
  </p>
  <div class="post">
    <p>During the holiday season I finally decided to learn something about <a href="https://en.wikipedia.org/wiki/Category_theory">Category
theory</a> because it seems to be <em>the</em> hot topic in the Haskell
community. The book I used to guide me in this journey is <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Category theory for
programmers</a> by Bartosz Milewski.</p>
<p>I cannot say I fully understood it, I&rsquo;m far away from doing so, but I want to
write down what I think I learned nonetheless. I hope this will clarify my
thoughts and maybe help someone else.</p>
<h2 id="what-is-category-theory">What is category theory</h2>
<p>Bartosz likes to say that Category theory is the science of structure and
composition. Since functional programmers believe, rightly imho, that programs
are nothing but a huge composition of functions it might be worthwhile to take a
look at it.</p>
<p>Generally speaking though, category theory is a branch of maths that tries to
define the structure of &ldquo;things&rdquo; by only studying the &ldquo;relationships&rdquo; between
them. It&rsquo;s closely related to <a href="https://en.wikipedia.org/wiki/Set_theory">Set theory</a> but the core difference
is that in category theory it&rsquo;s not allowed to define anything relying on
properties on the elements themselves, but only in terms of their connectivity.</p>
<h2 id="category">Category</h2>
<p>A category is a bunch of objects connected by arrows. Every category has two
properties:</p>
<ul>
<li>every object always has an identity arrow that points to itself;</li>
<li>the arrows, also called morphisms, must be composable that is if there&rsquo;s a
function from object <strong>A</strong> to <strong>B</strong> and from <strong>B</strong> to <strong>C</strong> then there must be
also an arrow from <strong>A</strong> to <strong>C</strong>. Moreover, the composition must be
associative that is <code>(f . g) . h = f . (g . h)</code>.</li>
</ul>
<p>If the second property sounds like the definition of function composition then
you&rsquo;re absolutely right! In fact, it turns out there is a category where the
objects are types and the arrows are the functions between them. In Haskell this
category is called <em>Hask</em>, but this concepts can be translated to other type
systems with almost no changes.</p>
<p>Here&rsquo;s an example of a simple category</p>
<img src="/post/category-theory/simple-category.svg" alt="simple category" class="image-centered">
<h2 id="isomorphism">Isomorphism</h2>
<p>Another core concept of category theory is the concept of <em>isomorphism</em>. This
buzzword means that there&rsquo;s an invertible arrow, a morphism, between two objects
in a category. In other words, the two objects are isomorphic.</p>
<p>Simply put, this means that the composition between the two arrows is the
identity arrow. In pseudo Haskell notation this could be expressed as <code>f . g = id</code>.</p>
<p>As a trivial example, let&rsquo;s show how <code>Maybe ()</code> is isomorphic to <code>Bool</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#06287e">isJust</span> <span style="color:#007020;font-weight:bold">::</span> <span style="color:#902000">Maybe</span> <span style="color:#007020">()</span> <span style="color:#007020;font-weight:bold">-&gt;</span> <span style="color:#902000">Bool</span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">isJust</span> (<span style="color:#902000">Just</span> <span style="color:#007020;font-weight:bold">_</span>) <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">True</span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">isJust</span> <span style="color:#902000">Nothing</span>  <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">justIf</span> <span style="color:#007020;font-weight:bold">::</span> <span style="color:#902000">Bool</span> <span style="color:#007020;font-weight:bold">-&gt;</span> <span style="color:#902000">Maybe</span> <span style="color:#007020">()</span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">justIf</span> <span style="color:#902000">True</span>  <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">Just</span> <span style="color:#007020">()</span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">justIf</span> <span style="color:#902000">False</span> <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">Nothing</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic">-- function comparison is not implemented in Haskell, but the following</span>
</span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic">-- statements shouldn&#39;t be too hard to verify</span>
</span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic">-- isJust . justIf = id</span>
</span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic">-- justIf . isJust = id</span>
</span></span></code></pre></div><img src="/post/category-theory/isomorphism-example.svg" alt="isomorphism example" class="image-centered">
<p>Clearly, <code>Maybe ()</code> is not semantically the same as <code>Bool</code> (i.e. they&rsquo;re not the
same type), but they actually carry the same amount of information albeit in a
different shape.</p>
<p>A use case I find quite interesting for isomorphisms is in compiler
optimizations. Theoretically a compiler could substitute a data type with
another data type that is isomorphic to the original one but that&rsquo;s more machine
efficient.</p>
<h2 id="duality">Duality</h2>
<p>Since a category is just a collection of objects and arrows it&rsquo;s always possible
to create the dual of a category by inverting the direction of the arrows. The
dual category is also called the <em>opposite</em> category or <strong>C</strong><sup><em>op</em></sup>.
This duality is interesting because it also means that structures built on a
category <strong>C</strong> also have a dual shape in <strong>C</strong><sup><em>op</em></sup>. Usually the dual
shapes are called with the same name with a <em>co</em> prefix.</p>
<p>For example, here&rsquo;s the opposite category of first example category</p>
<img src="/post/category-theory/simple-category-op.svg" alt="simple category" class="image-centered">
<p>Note how the identity arrows are preserved since their source and target are the
same object.</p>
<p>Also note that the dual of the dual of a category is the category itself that is
(<strong>C</strong><sup><em>op</em></sup>) <sup><em>op</em></sup> = <strong>C</strong>. This is why you can give a nut
to a category theorist even though he asked you a <em>coco</em>-nut.</p>
<h2 id="product">Product</h2>
<p>At this point we have the tools to understand one of the core shapes in category
theory: the <em>Product</em>. A <em>product</em> between two objects is an object that has two
morphisms to the original objects. Intuitively, a <em>Product</em> between two objects
is another object from which it&rsquo;s possible to retrieve both the original
objects. In Haskell pseudo-notation these two morphisms, also called
projections, can be written as</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#06287e">f</span> <span style="color:#007020;font-weight:bold">::</span> p <span style="color:#007020;font-weight:bold">-&gt;</span> a
</span></span><span style="display:flex;"><span><span style="color:#06287e">g</span> <span style="color:#007020;font-weight:bold">::</span> p <span style="color:#007020;font-weight:bold">-&gt;</span> b
</span></span></code></pre></div><p>Using this definition there could be multiple valid product objects for any two
objects. To solve this ambiguity there&rsquo;s an additional constraint the product
must satisfy: it must have a unique morphism to any other candidate product
object. I know it sounds scary, but all it means is that the product object
cannot be built from any other candidate product object. In other words, the
product object has less structure than the other candidate products.</p>
<p>Here&rsquo;s the graph for the product <strong>P</strong>. Note that I&rsquo;ve omitted the identity
morphisms for simplicity only.</p>
<img src="/post/category-theory/product.svg" alt="product" class="image-centered">
<p>In this diagram, there are two candidate product objects: <strong>P</strong> and <strong>P&rsquo;</strong>.
However, only <strong>P</strong> is the product between <strong>A</strong> and <strong>B</strong> because there&rsquo;s a
morphism <em>h</em> that can be used to go from <strong>P&rsquo;</strong> to <strong>P</strong>.</p>
<p>In Haskell, the product of two types is the two element tuple <code>(a, b)</code> which can
also be expressed as <code>data Product a b = Product a b</code>. The projections are
simply the <code>fst</code> and <code>snd</code> functions.</p>
<p>As an example of a Haskell type that is a candidate for being the product type
let&rsquo;s consider <code>(a, b, Int)</code>. It&rsquo;s easy to show that the morphism that builds
<code>(a, b)</code> from it is</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#06287e">h</span> <span style="color:#007020;font-weight:bold">::</span> (a, b, <span style="color:#902000">Int</span>) <span style="color:#007020;font-weight:bold">-&gt;</span> (a, b)
</span></span><span style="display:flex;"><span><span style="color:#06287e">h</span> (a, b, <span style="color:#007020;font-weight:bold">_</span>) <span style="color:#007020;font-weight:bold">=</span> (a, b)
</span></span></code></pre></div><p>Therefore we can say that <code>(a, b, Int)</code> is not the product of <code>a</code> and <code>b</code>.</p>
<h2 id="coproduct">Coproduct</h2>
<p>In category theory, as soon as a pattern is found, the next thing to do is to
apply the duality concept to find its dual pattern. In our case let&rsquo;s build the
dual of the product: the <em>coproduct</em>.</p>
<p>This is the product diagram with the arrows inverted.</p>
<img src="/post/category-theory/sum.svg" alt="sum" class="image-centered">
<p>The intuition behind this is that a <em>coproduct</em> is an object that can be built
either by <strong>A</strong> or by <strong>B</strong>. In fact, there are two morphisms, also known as
injections, that create a coproduct. Sure enough, there could be multiple
coproducts for the same pair of objects, but just like a product, the coproduct
cannot be built from any other coproduct candidate.</p>
<p>This might be a bit harder to recognize, but if we try hard enough we can see
the pattern of algebraic data types! In fact, in Haskell we can define the
<em>coproduct</em> in the following way</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">data</span> <span style="color:#902000">Coproduct</span> a b <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">CoproA</span> a <span style="color:#666">|</span> <span style="color:#902000">CoproB</span> b
</span></span></code></pre></div><p>The two injections are the value constructors.</p>
<p>You might recognize this declaration as the declaration of the <code>Either</code> data
type and you&rsquo;d be right because they&rsquo;re isomorphic to each other!</p>
<h2 id="algebra">Algebra</h2>
<p>Both product and coproduct, also known as <em>sum</em>, have names of arithmetic
operations but they don&rsquo;t seem to relate to the concept of addition and
multiplication. Accident? As Master Oogway says, there is no accident.</p>
<p>As a refresher, here are the definitions of <code>Product</code> and <code>Sum</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">data</span> <span style="color:#902000">Product</span> a b <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">Product</span> a b
</span></span><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">data</span> <span style="color:#902000">Sum</span> a b <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">SumA</span> a <span style="color:#666">|</span> <span style="color:#902000">SumB</span> b
</span></span></code></pre></div><p>One of the questions we can ask is how many ways are there to create any of
these patterns.</p>
<p>Let&rsquo;s start with the product. If it had a single type parameter then the number
of values would simply be the number of distinct values in the wrapped type.
Since in the real product there are two type parameters, the total number of
ways to build a product is the product of the number of distinct values in each
type parameter!</p>
<p>We can apply the same reasoning to sum. To build a sum we either need an <em>a</em> or
a <em>b</em> but not both. Therefore the number of ways of building a sum is just the
sum of the values in the type parameters.</p>
<p>Now that we have operations to combine (positive) numbers it might be worthwhile
to find an encoding for the numbers themselves.</p>
<p>Let&rsquo;s start with the number one. In this line of reasoning, one means that there
should be only a single value for that type. It&rsquo;s not too hard to come up with a
valid definition. In Haskell something like the following will work</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">data</span> <span style="color:#902000">One</span> <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">One</span>
</span></span></code></pre></div><p>There&rsquo;s just one way of instantiating the type One that is by using the <em>value</em>
constructor One. Note how One is isomorphic to <code>()</code>.</p>
<p>Now that we have One we can have two, three, etc.. simply by using sums and
products! Take a look at the following type definitions</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">type</span> <span style="color:#902000">Two</span> <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">Sum</span> <span style="color:#902000">One</span> <span style="color:#902000">One</span>
</span></span><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">type</span> <span style="color:#902000">Four</span> <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">Product</span> <span style="color:#902000">Two</span> <span style="color:#902000">Two</span>
</span></span></code></pre></div><p>Let&rsquo;s check if this actually works by enumerating all the ways we can build
those types:</p>
<ul>
<li>we can build a Two using either <code>SumA One</code> or <code>SumB One</code>;</li>
<li>a Four can be built with <code>Product (SumA One) (SumA One)</code>, <code>Product (SumA One) (SumB One)</code>, <code>Product (SumB One) (SumA One)</code> and <code>Product (SumB One) (SumB One)</code>.</li>
</ul>
<p>It seems to work, neat!</p>
<p>However we haven&rsquo;t yet found an encoding for zero. Let&rsquo;s fix that now, here&rsquo;s
the definition</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">data</span> <span style="color:#902000">Zero</span>
</span></span></code></pre></div><p>In Haskell it&rsquo;s possible to define a type without any value constructors. This
means that we can never create any value of this type. This is also known as the
<code>Void</code> type (which is not the same as <code>void</code> in c/c++). In C++ a type isomorphic
to zero can be defined in terms of a class with a private constructor.</p>
<p>Note how Zero is the identity for Sum as well as One is for Product. Also note
how any Product with Zero ends up in no ways of building that type because at
some point you will have to instantiate a Zero which is impossible.</p>
<p>If we substitute numbers with types it becomes evident that creating new types
is just a composition over Sums and Products (if we can create any number we can
create any type). This allows the creation of a generic framework to manipulate
data types which is how the Haskell compiler is able to implement a lot of
typeclasses automatically.</p>
<h2 id="curry-howard-isomorphism">Curry-Howard isomorphism</h2>
<p>It&rsquo;s possible to show that products and sums can be transformed into constructs
in logic. In particular a product would be <em>logical and</em> or <code>&amp;&amp;</code> and a sum would
be a <em>logical or</em> or <code>||</code>. Furthermore, Zero would correspond to <em>false</em> and One
to <em>true</em>.</p>
<p>It&rsquo;s quite easy to show that the familiar properties about such constructs hold.
For example <code>a &amp;&amp; false = false</code> holds because if we translate the proposition
to sums and products it eventually evaluates to <code>Product a Zero</code> which we know
is always <code>Zero</code>. This same approach can be used to show that <code>a || true = true</code>.</p>
<p>We can also show how functions can be mapped to <em>logical implication</em> or <code>a -&gt; b</code> meaning that if <em>a</em> is <em>true</em> then we can say <em>b</em>. The obvious question here
is what happens when <em>a</em> is <em>false</em>? Well, the function would be of type <code>Zero -&gt; b</code> but if we look closely we might realize that we can never call that
function because Zero doesn&rsquo;t have any values! Therefore we cannot conclude <em>b</em>.</p>
<p>An interesting interpretation of this is that, since all the possible types are
a combination of products and sums and that we can map sums and products to
logical constructs then we can say that there&rsquo;s an isomorphism between types and
logic! This is known as the <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard
isomorphism</a>. Under this point a view, checking if a
program type-checks is no different than checking whether a logical proposition
holds or not.</p>
<h2 id="functor">Functor</h2>
<p>A <em>functor</em> is a mapping between categories which maps both objects and
morphisms. When the target category of the functor is the same as the source
category then the functor is called <em>endofunctor</em>. In programming we don&rsquo;t
usually have multiple categories because we live only in the category of types
therefore in this context a functor actually is an endofunctor.</p>
<p>In Haskell a (endo)functor can be defined in the following way:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">class</span> <span style="color:#902000">Functor</span> f <span style="color:#007020;font-weight:bold">where</span>
</span></span><span style="display:flex;"><span>  fmap <span style="color:#007020;font-weight:bold">::</span> (a <span style="color:#007020;font-weight:bold">-&gt;</span> b) <span style="color:#007020;font-weight:bold">-&gt;</span> (f a <span style="color:#007020;font-weight:bold">-&gt;</span> f b)
</span></span></code></pre></div><p>The mapping between objects is in the fact that <code>f</code> must be a type constructor
that is a type that needs a single type parameter in order to be instantiated.
For example, <code>Maybe</code> and <code>Either String</code> are both type constructors because they
require only another type parameter but <code>Either</code> is not because it requires 2
type parameters. Note that also <code>Either String Int</code> or <code>Int</code> are not type
constructors because they&rsquo;re types and as such they require no type parameters.
We can see a type constructor <strong>T</strong> as taking the type parameter and mapping it
into category <strong>T</strong>.</p>
<p>If we try hard enough we can also see how <code>fmap</code> is doing the mapping between
morphisms, that is functions, from one category to another one. In fact it takes
the morphism <code>a -&gt; b</code> which is mapped to the morphism <code>f a -&gt; f b</code> in category
<strong>F</strong>.</p>
<p>Here&rsquo;s an example implementation of Functor for Maybe</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">instance</span> <span style="color:#902000">Functor</span> <span style="color:#902000">Maybe</span> <span style="color:#007020;font-weight:bold">where</span>
</span></span><span style="display:flex;"><span>  fmap f (<span style="color:#902000">Just</span> x) <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">Just</span> (f x)
</span></span><span style="display:flex;"><span>  fmap <span style="color:#007020;font-weight:bold">_</span> <span style="color:#902000">Nothing</span> <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">Nothing</span>
</span></span></code></pre></div><p>Functors are really common in programming. My intuition is that they represent
some sort of containers. For example, the Maybe type can be seen as a container
of an optional value and a list can be seen as a plain container of values.</p>
<h2 id="monoid">Monoid</h2>
<p>Another interesting pattern is the <em>Monoid</em>. A <em>Monoid</em> is an object equipped
with a unit arrow and an associative multiplication arrow.</p>
<p>In Haskell this could be expressed as</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">class</span> <span style="color:#902000">Monoid</span> m <span style="color:#007020;font-weight:bold">where</span>
</span></span><span style="display:flex;"><span>  mempty <span style="color:#007020;font-weight:bold">::</span> m
</span></span><span style="display:flex;"><span>  mappend <span style="color:#007020;font-weight:bold">::</span> m <span style="color:#007020;font-weight:bold">-&gt;</span> m <span style="color:#007020;font-weight:bold">-&gt;</span> m
</span></span></code></pre></div><p>Note that in Haskell mempty is not actually an arrow but a value of type <code>m</code>
because it can be shown that <code>m</code> is isomorphic to <code>() -&gt; m</code> (there&rsquo;s only a
single way of calling <code>() -&gt; m</code>).</p>
<p>These morphisms must satisfy the following laws</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#06287e">mappend</span> mempty m <span style="color:#007020;font-weight:bold">=</span> m
</span></span><span style="display:flex;"><span><span style="color:#06287e">mappend</span> m mempty <span style="color:#007020;font-weight:bold">=</span> m
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(mappend x <span style="color:#666">.</span> mappend y) <span style="color:#666">.</span> mappend z <span style="color:#007020;font-weight:bold">=</span> mappend x <span style="color:#666">.</span> (mappend y <span style="color:#666">.</span> mappend z)
</span></span></code></pre></div><p>To put it simply, mappend is an associative &ldquo;multiplication-like&rdquo; morphism and
mempty is the identity value under mappend.</p>
<p>I know this definition isn&rsquo;t very clear, but hopefully an example helps.
Probably the simplest example of a Monoid is the product of numbers. In fact
it&rsquo;s easy to show that the mempty value is 1 and that mappend is simply the <code>*</code>
operator.</p>
<p>Here&rsquo;s a possible implementation in Haskell</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">data</span> <span style="color:#902000">ProductM</span> <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">ProductM</span> <span style="color:#902000">Int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">instance</span> <span style="color:#902000">Monoid</span> <span style="color:#902000">ProductM</span> <span style="color:#007020;font-weight:bold">where</span>
</span></span><span style="display:flex;"><span>  mempty <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">ProductM</span> <span style="color:#40a070">1</span>
</span></span><span style="display:flex;"><span>  mappend (<span style="color:#902000">ProductM</span> a) (<span style="color:#902000">ProductM</span> b) <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">ProductM</span> (a <span style="color:#666">*</span> b)
</span></span></code></pre></div><p>The real definition is a bit different because ProductM must also be a
<em>Semigroup</em> in order to be a Monoid. Let&rsquo;s ignore this detail by just saying
that a Semigroup is a Monoid without the identity value; it&rsquo;s just the
associative morphism.</p>
<p>Besides the usual unwrapping and rewrapping the implementation should be quite
straightforward to follow. I won&rsquo;t bother demonstrating that <code>ProductM</code> indeed
satisfies the monoid requirements because I think we can all agree that it&rsquo;s
just multiplication.</p>
<p>Note how numbers form a monoid over addition too. In this case the mempty value
is 0 and mapped is simply the <code>+</code> operator.</p>
<p>Monoids are extremely useful in practice! Basically every container I can think
of is a Monoid under the concatenation morphism. Here&rsquo;s an hopefully easy to
understand implementation of Monoid for lists in Haskell</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">instance</span> <span style="color:#902000">Monoid</span> [a] <span style="color:#007020;font-weight:bold">where</span>
</span></span><span style="display:flex;"><span>  mempty <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">[]</span>
</span></span><span style="display:flex;"><span>  mappend <span style="color:#007020;font-weight:bold">=</span> concat
</span></span></code></pre></div><p>It should be quite evident how this definition can be mapped to nearly every
container.</p>
<p>Also note how the implementation of Monoid for lists is totally generic over the
contained value. That&rsquo;s why lists are also known as <em>Free monoids</em>; they give
you a Monoid <em>for free</em>.</p>
<p>To show you how much monoids are useful let&rsquo;s solve a simple problem: find the
sum and product of a sequence of numbers in a single pass. Here&rsquo;s how it could
be done in Haskell</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#06287e">f</span> <span style="color:#007020;font-weight:bold">::</span> [<span style="color:#902000">Int</span>] <span style="color:#007020;font-weight:bold">-&gt;</span> (<span style="color:#902000">Product</span> <span style="color:#902000">Int</span>, <span style="color:#902000">Sum</span> <span style="color:#902000">Int</span>)
</span></span><span style="display:flex;"><span><span style="color:#06287e">f</span> <span style="color:#007020;font-weight:bold">=</span> foldl mappend mempty <span style="color:#666">.</span> map (<span style="color:#06287e">\</span>n <span style="color:#007020;font-weight:bold">-&gt;</span> (<span style="color:#902000">Product</span> n, <span style="color:#902000">Sum</span> n))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic">-- or using mconcat which is equivalent to the above manual foldl</span>
</span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic">-- f = mconcat . map (\n -&gt; (Product n, Sum n))</span>
</span></span></code></pre></div><p>Pretty sick, isn&rsquo;t it? The key point here is that also the tuple is a Monoid as
long as its components do!</p>
<h2 id="comonoid">Comonoid</h2>
<p>If there is a Monoid there must be also a <em>Comonoid</em> in the opposite category,
right? Indeed there is. Unfortunately I don&rsquo;t understand it completely.</p>
<p>After reversing the arrows eventually we get to a definition like the following</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">class</span> <span style="color:#902000">Comonoid</span> m <span style="color:#007020;font-weight:bold">where</span>
</span></span><span style="display:flex;"><span>  destroy <span style="color:#007020;font-weight:bold">::</span> m <span style="color:#007020;font-weight:bold">-&gt;</span> <span style="color:#007020">()</span>
</span></span><span style="display:flex;"><span>  dup <span style="color:#007020;font-weight:bold">::</span> m <span style="color:#007020;font-weight:bold">-&gt;</span> (m, m)
</span></span></code></pre></div><p>where dup must be associative and must return an exact copy of the input. In
Haskell the only possible definitions of these morphisms are</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#06287e">destroy</span> <span style="color:#007020;font-weight:bold">::</span> a <span style="color:#007020;font-weight:bold">-&gt;</span> <span style="color:#007020">()</span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">destroy</span> <span style="color:#007020;font-weight:bold">_</span> <span style="color:#007020;font-weight:bold">=</span> <span style="color:#007020">()</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">dup</span> <span style="color:#007020;font-weight:bold">::</span> a <span style="color:#007020;font-weight:bold">-&gt;</span> (a, a)
</span></span><span style="display:flex;"><span><span style="color:#06287e">dup</span> a <span style="color:#007020;font-weight:bold">=</span> (a, a)
</span></span></code></pre></div><p>And that&rsquo;s why it&rsquo;s hard for me to understand. With only this possible
definition I&rsquo;m not able to see a general pattern. Anyway, my intuition is if a
Monoid builds a somewhat bigger object at each mappend then the Comonoid, its
dual, must gradually destroy the already built object. I don&rsquo;t think that&rsquo;s 100%
accurate though.</p>
<p>It seems <a href="https://stackoverflow.com/questions/23855070/what-does-a-nontrivial-comonoid-look-like">that a Comonoid can be used to model linear type
systems</a> upon which many new languages are based upon.
Rust and Idris are examples of languages with a linear type system.</p>
<h2 id="monad">Monad</h2>
<p>It&rsquo;s time for the big one: the <em>Monad</em>.</p>
<blockquote>
<p>A monad is <em>just</em> a monoid in the category of endofunctors.</p>
</blockquote>
<p>If the definition doesn&rsquo;t say anything to you don&rsquo;t worry, you&rsquo;re not alone.
I&rsquo;ll try my best to explain this definition as simple as I can.</p>
<p>First of all, the definition says we&rsquo;re in the category of <em>endofunctors</em> which
means that objects in this category are endofunctors. Since a monad is a monoid
by definition, there must be an arrow that somehow multiplies two endofunctors
together. In addition, there must be a unit arrow as well. These arrows are
called <em>natural transformation</em> s. I know this is still a bit nebulous, so let&rsquo;s
cut it short and take a look at its definition in Haskell</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">class</span> <span style="color:#902000">Functor</span> m <span style="color:#007020;font-weight:bold">=&gt;</span> <span style="color:#902000">Monad</span> m <span style="color:#007020;font-weight:bold">where</span>
</span></span><span style="display:flex;"><span>  return <span style="color:#007020;font-weight:bold">::</span> a <span style="color:#007020;font-weight:bold">-&gt;</span> m a
</span></span><span style="display:flex;"><span>  join <span style="color:#007020;font-weight:bold">::</span> m (m a) <span style="color:#007020;font-weight:bold">-&gt;</span> m a
</span></span></code></pre></div><p>I think we can vaguely see how <em>return</em> is similar to mempty (especially to <code>() -&gt; m</code>): it takes a value and simply wraps it inside the monad. Like mempty this
can be seen as the entry point of a monad.</p>
<p>On the other hand, the <em>join</em> function is a bit more difficult to relate to
mappend, but the intuition is that join is actually doing the product within the
monad itself. This ends up in a flattening of the structure of the Monad.</p>
<p>Let&rsquo;s see how <code>Maybe</code> implements Monad</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">instance</span> <span style="color:#902000">Monad</span> <span style="color:#902000">Maybe</span> <span style="color:#007020;font-weight:bold">where</span>
</span></span><span style="display:flex;"><span>  return <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">Just</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  join (<span style="color:#902000">Just</span> a) <span style="color:#007020;font-weight:bold">=</span> a
</span></span><span style="display:flex;"><span>  join <span style="color:#902000">Nothing</span> <span style="color:#007020;font-weight:bold">=</span> <span style="color:#902000">Nothing</span>
</span></span></code></pre></div><p>However, in Haskell the monad is not defined in terms of join but instead in
terms of the <em>bind</em> operator or <code>&gt;&gt;=</code>. It&rsquo;s possible to show that bind can be
defined in terms of join. Here&rsquo;s how it could be done</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>(<span style="color:#666">&gt;&gt;=</span>) <span style="color:#007020;font-weight:bold">::</span> <span style="color:#902000">Monad</span> m <span style="color:#007020;font-weight:bold">=&gt;</span> (a <span style="color:#007020;font-weight:bold">-&gt;</span> m b) <span style="color:#007020;font-weight:bold">-&gt;</span> m a <span style="color:#007020;font-weight:bold">-&gt;</span> m b
</span></span><span style="display:flex;"><span><span style="color:#06287e">f</span> (<span style="color:#666">&gt;&gt;=</span>) m <span style="color:#007020;font-weight:bold">=</span> join <span style="color:#666">.</span> fmap f <span style="color:#666">$</span> m
</span></span></code></pre></div><p>However, I don&rsquo;t think this categorical definition of a monad explains very well
what a monad is in the context of programming. My intuition for the monad is
that it&rsquo;s a context inside which we can encapsulate values and compose functions
without ever leaving the context. For example, in the case of Maybe the context
is uncertainty because we don&rsquo;t know for sure whether a value is present or not.
Every function that works on a Maybe inherits this uncertainty because it must
remain in context.</p>
<h2 id="comonad">Comonad</h2>
<p>This is the last pattern we&rsquo;ll talk about: the <em>Comonad</em>, the dual of the Monad.</p>
<p>If we try to reverse the definition of a monad we eventually get to the
following Haskell definition of a comonad</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">class</span> <span style="color:#902000">Functor</span> m <span style="color:#007020;font-weight:bold">=&gt;</span> <span style="color:#902000">Comonad</span> m <span style="color:#007020;font-weight:bold">where</span>
</span></span><span style="display:flex;"><span>  extract <span style="color:#007020;font-weight:bold">::</span> m a <span style="color:#007020;font-weight:bold">-&gt;</span> a
</span></span><span style="display:flex;"><span>  duplicate <span style="color:#007020;font-weight:bold">::</span> m a <span style="color:#007020;font-weight:bold">-&gt;</span> m (m a)
</span></span></code></pre></div><p>If you look at it long enough you might see similarities to the Comonoid. In
fact</p>
<blockquote>
<p>A comonad is <em>just</em> a comonoid in the category of endofunctors</p>
</blockquote>
<p>I think I understand the comonad more than the comonoid even though the former
is defined on the latter. My intuition is that, if the monad provides a way of
encapsulating a value inside a context without providing a way of accessing it
outside the context then the comonad must be all about extracting values from a
context. The <em>extract</em> function should reflect this logic quite clearly. On the
other hand, <em>duplicate</em> is the exact opposite of join because it adds another
layer of nesting in the comonad.</p>
<h2 id="yoneda-lemma">Yoneda lemma</h2>
<p>I&rsquo;ve talked enough about category theory under a mathematical point of view.
Maths has always been connected to philosophy from its origins and sure enough
category theory is no exception.</p>
<p>In particular, I&rsquo;d like to mention the Yoneda lemma which (semantically) says
that</p>
<blockquote>
<p>Every object is completely identified by the morphisms towards the other
objects.</p>
</blockquote>
<p>I have not understood what it actually means in category theory, but I find it
quite fascinating when applied to the category of the real world. In this
category, where objects correspond to people and arrows correspond to the
relationships between them, the Yoneda lemma means that each one of us is
uniquely defined by our relationships. I don&rsquo;t think that&rsquo;s too far away from
the truth.</p>
<h2 id="haskell-point-free-notation">Haskell point free notation</h2>
<p>During my journey in category theory, I also learned why the point free notation
is so named in Haskell. If you don&rsquo;t know what it is it&rsquo;s a style of writing
functions where arguments are not explicitly mentioned. The main tool to achieve
this is by using function composition. Here&rsquo;s an example</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#06287e">oddSquares</span> <span style="color:#007020;font-weight:bold">::</span> [<span style="color:#902000">Int</span>] <span style="color:#007020;font-weight:bold">-&gt;</span> [<span style="color:#902000">Int</span>]
</span></span><span style="display:flex;"><span><span style="color:#06287e">oddSquares</span> <span style="color:#007020;font-weight:bold">=</span> map (<span style="color:#666">*</span> <span style="color:#40a070">2</span>) <span style="color:#666">.</span> filter odd
</span></span></code></pre></div><p>As you can see, this function takes a single parameter, a list of numbers, which
is not mentioned explicitly in the function definition.</p>
<p>It&rsquo;s so named because arguments can also be called points in the sense of
<em>calculating the function at the given points</em>. The fact that the function
composition operator is a point too is an unfortunate coincidence.</p>
<h2 id="conclusions">Conclusions</h2>
<p>Category theory has way more concepts than what I tried to describe here and I
didn&rsquo;t understand most of them. For example, I didn&rsquo;t get T-Algebras,
Adjunctions, Kan extensions, the Lawvere theory and many more!</p>
<p>My main problem with category theory is that I cannot relate to most of its
concepts. In other words, I&rsquo;m not able to understand what I cannot use. I want
to improve with regard to this, but it&rsquo;s hard.</p>
<p>However, I think that even with this tiny subset of category theory the inner
structure of a lot of problems can be revealed. Hopefully it also helps building
well structured software.</p>

  </div>

</section>

</main>

<footer class="footer">
    <div class="container footer-container">
        <div style="margin-right: auto">
            © 2023 Daniele D'Orazio
        </div>

        <div class="footer-icon">
            <a href="https://github.com/danieledapo">
                <i class="fab fa-github" aria-hidden="true"></i>
            </a>
        </div>
        <div class="footer-icon">
            <a href="https://twitter.com/danieled__">
                <i class="fab fa-twitter" aria-hidden="true"></i>
            </a>
        </div>
        <div class="footer-icon">
            
        </div>
    </div>

</footer>
</body>

</html>

